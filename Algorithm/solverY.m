% settings.conv_threshold_HP = 0.00005;
convergence_absolute = 'true';

pre_driver_effect = 0;
Charge_on_wire_done(stack_mol.num,5)=0;
n_times = size(stack_clock,2)-1;

for time = 2:n_times+1
    time
    
    stack_energy(time-1).time = time;
    stack_energy(time-1).steps = 0;
    
    %driver selection
	for ff=1:stack_driver.num
     	for tt=1:size(driver_values,1)
         	if strcmp(stack_driver.stack(ff).identifier{1},driver_values{tt,1})
% %                 if driver_values{tt,ii} == 1 %windows version
%                	if driver_values{tt,time} == '1'
%                     stack_driver.stack(ff).charge(1).q = 0.003;
%                     stack_driver.stack(ff).charge(2).q = 0.9270;
%                     stack_driver.stack(ff).charge(3).q = -0.212;
%                     stack_driver.stack(ff).charge(4).q = 0.283;
%                    	flag = 1;
% %               	elseif driver_values{tt,ii} == 0 %windows version
%                 elseif driver_values{tt,time} == '0'
%                     stack_driver.stack(ff).charge(1).q = 0.9283;
%                     stack_driver.stack(ff).charge(2).q = 7.0011e-04;
%                     stack_driver.stack(ff).charge(3).q = -0.2120;
%                     stack_driver.stack(ff).charge(4).q = 0.2830;
%                     flag = 1;
%                 end
                
            [P1, P2, P3, P4] = SearchValues( driver_values{tt,time}, +2, CK );
            [ Q1, Q2,  Q3, Q4 ] = Intersection( driver_values{tt,time}, +2, P1, P2, P3, P4 );
            stack_driver.stack(ff).charge(1).q =  Q1;    
            stack_driver.stack(ff).charge(2).q =  Q2;   
            stack_driver.stack(ff).charge(3).q =  Q3;   
            stack_driver.stack(ff).charge(4).q =  Q4;   
            flag=1;
            end
        end
    end 

    %Function_Saver(1, time, fileID, 0, Charge_on_wire_done, stack_mol, stack_driver);     
        
    %clock selection
    for ii_mol =1:stack_mol.num
        stack_mol.stack(ii_mol).clock = stack_clock{ii_mol,time};
    end
    
    %evaluation
    if time>2 %not the first time
        %switch off the previous driver
        Vout = Vout - pre_driver_effect;
        %switch on the new driver
        V_driver = yDrivers_effect( stack_driver, stack_mol);
        Vout = Vout+V_driver;
    else %first time
        V_driver = yDrivers_effect( stack_driver, stack_mol);
        Vout = zeros(1,stack_mol.num);
    end

    %evaluation
    max_error=settings.conv_threshold_HP;
    err=2*max_error; %ensure loop tarting
    step=0;
    while(err>max_error)
        
        step=step+1
        if (step==200)
            max_error=settings.conv_threshold_LP;
            disp('Warning: low precision');
        end
        if (step==300)
            max_error=settings.conv_threshold_LLP;
            disp('Warning very low precision');
        end
        if (settings.y.enable_escape==1 && step==350)
            pause
            break;
        end

        %save last voltage for error evaluation
        preV = Vout;

        %evaluate voltage on each molecule
        for jj_mol=1:stack_mol.num

            %insert effect of the driver on ii-th molecule
            Vout(jj_mol)=V_driver(jj_mol); 

            %evaluate voltage generated by other molecules
            for ii_mol = 1:stack_mol.num
                if ii_mol~=jj_mol

                    Vout(jj_mol) = Vout(jj_mol) + ChargeBased_CalPotential(stack_mol.stack(ii_mol), stack_mol.stack(jj_mol));
                end    
            end

            %update charges
            [P1, P2, P3, P4] = SearchValues( Vout(jj_mol), stack_mol.stack(jj_mol).clock, CK );
            [ Q1, Q2,  Q3, Q4 ] = Intersection( Vout(jj_mol), stack_mol.stack(jj_mol).clock, P1, P2, P3, P4 );
            stack_mol.stack(jj_mol).charge(1).q =  Q1;    
            stack_mol.stack(jj_mol).charge(2).q =  Q2;   
            stack_mol.stack(jj_mol).charge(3).q =  Q3;   
            stack_mol.stack(jj_mol).charge(4).q =  Q4;   
        end

        %convergence error
        if (strcmp(convergence_absolute,'true'))
            err=max(Vout-preV);
        else
            err=max(Vout-preV)/norm(preV);
        end

        if settings.y.show_intermediate_steps == 1
    %     plots
        figure(250000000), clf, hold on
            plot(preV)
            plot(Vout) 
            plot(V_driver)
            plot([1 stack_mol.num],[0 0],'--k')
            legend ('preV','V','driver')
            grid on, grid minor
            axis([1 stack_mol.num -Inf +Inf])

        drawnow
        end

        % pause
        
        %save energy
%         [W_int,W_ex,W_clk,W_tot] = EvaluateEnergy(stack_driver, stack_mol, Vout, CK);
%         stack_energy(time-1).steps = stack_energy(time-1).steps+1;
%         stack_energy(time-1).W_int(stack_energy(time-1).steps) = W_int;
%         stack_energy(time-1).W_ex(stack_energy(time-1).steps) = W_ex;
%         stack_energy(time-1).W_clk(stack_energy(time-1).steps) = W_clk;
%         stack_energy(time-1).W_tot(stack_energy(time-1).steps) = W_tot;
        
        
    end

    %save current voltage of the driver
    pre_driver_effect = V_driver;
    
    %charges
    for cc_mol = 1:stack_mol.num
        Charge_on_wire_done(cc_mol,1) = cc_mol;
        Charge_on_wire_done(cc_mol,2) = stack_mol.stack(cc_mol).charge(1).q;
        Charge_on_wire_done(cc_mol,3) = stack_mol.stack(cc_mol).charge(2).q;
        Charge_on_wire_done(cc_mol,4) = stack_mol.stack(cc_mol).charge(3).q;
        Charge_on_wire_done(cc_mol,5) = stack_mol.stack(cc_mol).charge(4).q;
    end
   
    run('ConvergenceTable.m')
    
    %plot
    Function_Plotting(Vout, Charge_on_wire_done, stack_mol, stack_driver,settings.fig_saver, 3*time-2);
    Function_Saver(0, time, fileID, Vout, Charge_on_wire_done, stack_mol, stack_driver);        
end


